substitutions:
  name: marstek-m1
  friendly_name: MT1

## Version 1.0 
esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.7.0
  name_add_mac_suffix: false
  platformio_options:
    board_build.flash_mode: dio

esp32:
  board: esp32-s3-devkitc-1  ## M5stack Atom S3 lite  
  flash_size: 8MB
  framework:
    type: esp-idf
    version: recommended
    ## Custom sdkconfig options
    sdkconfig_options:
      COMPILER_OPTIMIZATION_SIZE: y
      CONFIG_BT_ENABLED: n

## Modbus TCP/IP external component
external_components:
  - source:
      type: git
      url: https://github.com/rosenrot00/esphome_modbus_bridge
    components: [modbus_bridge]

## Enable/Disable logging
logger:
  logs:
    modbus_controller.sensor: INFO
    modbus_controller.output: INFO
    modbus.number: INFO
    esp32.preferences: INFO
    light: INFO
    component: ERROR
  
## Enable Home Assistant API
api:
  reboot_timeout: 0s
#  encryption:
#    key: !secret marstek_m1_api_encryption_key

## Enable OTA updates
ota:
  - platform: esphome
  - platform: web_server
#  password: !secret marstek_m1_ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 0s
  fast_connect: true
  power_save_mode: high

## uncomment if you need a fixed ip address
#  manual_ip:
#    static_ip: 192.168.178.126
#    gateway: 192.168.178.1
#    subnet: 255.255.255.0

## Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${friendly_name} Hotspot"
    password: "configesp"
    ap_timeout: 15s

captive_portal:
  id: id_captive_portal

web_server:
  port: 80
  version: 3
  include_internal: False
  local: True
  sorting_groups:
    - id: Diagnostic
      name: "Diagnostic"
      sorting_weight: -10

## Configure i2c (grove port on Atom S3)
i2c:
  - id: bus_a
    sda: 
      number: GPIO2
    scl: 
      number: GPIO1

## Configure UART
uart:
  - id: mod_bus
    tx_pin:
      number: GPIO6
    rx_pin:
      number: GPIO5
    baud_rate: 115200
    data_bits: 8
    stop_bits: 1
    parity: NONE
    rx_buffer_size: 256         # min. 256 recommended; increase for very long RTU responses

## Configure MODBUS TCP/IP bridge
modbus_bridge:
  id: mb_bridge
  uart_id: mod_bus
  tcp_port: 502               # TCP port
  tcp_poll_interval: 50       # ms between TCP polls
  tcp_client_timeout: 60000   # ms inactivity until TCP client is disconnected
  tcp_allowed_clients: 4      # clamped to minimum 1, use with care as it increases memory usage
  rtu_response_timeout: 3000  # ms, clamped internally to minimum of 10 ms)

## Configure Debug Switch (Webserver debug window)
switch:
  - platform: template
    name: "Modbus Bridge Debug"
    id: modbus_debug_switch
    icon: mdi:file-document-check-outline
    restore_mode: RESTORE_DEFAULT_OFF  # debug disabled by default; persists across reboots
    turn_on_action:
      - lambda: |-
          id(mb_bridge).set_debug(true);
          id(modbus_debug_switch).publish_state(true);
    turn_off_action:
      - lambda: |-
          id(mb_bridge).set_debug(false);
          id(modbus_debug_switch).publish_state(false);

## Textsensors diagnostics
text_sensor:
  - platform: wifi_info
    ip_address:
      name: ESP IP
      icon: mdi:ip
      web_server:
        sorting_group_id: Diagnostic
        sorting_weight: 1
    ssid:
      name: ESP SSID
      icon: mdi:wifi
      web_server:
        sorting_group_id: Diagnostic
        sorting_weight: 2

  - platform: version
    name: ESP Version
    hide_timestamp: true
    disabled_by_default: false
    icon: mdi:new-box
    entity_category: diagnostic
    web_server:
      sorting_group_id: Diagnostic
      sorting_weight: 6

sensor:
  - platform: internal_temperature
    icon: mdi:thermometer
    name: "Atom temperature"
    update_interval: 30s
    entity_category: diagnostic
    web_server:
      sorting_group_id: Diagnostic
      sorting_weight: 7

  - platform: wifi_signal
    name: "ESP WiFi Signal Strength"
    icon: mdi:wifi
    id: wifi_strength
    update_interval: 30s
    entity_category: diagnostic
    web_server:
      sorting_group_id: Diagnostic
      sorting_weight: 4

  - platform: copy # Reports the WiFi signal strength in %
    source_id: wifi_strength
    name: ESP Wifi signal
    id: wifi_signal_proc
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"
    entity_category: diagnostic
    device_class: ""
    icon: mdi:wifi
    web_server:
      sorting_group_id: Diagnostic
      sorting_weight: 5

## Simple status led for Atom s3 (lite)
## G35=RGB WS2812C-2020
##
## ðŸŸ¢ Green on => wifi connected- api connected/ Green blinking => wifi connected - api disconnected
## ðŸŸ£ Purple => wifi disconnected
## ðŸ”µ Blue => AP mode
light:
  - platform: esp32_rmt_led_strip
    id: status_led
    name: Status led
    icon: mdi:lightbulb
    internal: true # Hides from Home Assistant
    rgb_order: GRB
    pin: 35
    num_leds: 4
    chipset: ws2812
#    rmt_channel: 0 #only on platform: arduino
    restore_mode: ALWAYS_OFF
    entity_category: diagnostic
    effects:
      - pulse:
          name: slow_pulse
          transition_length: 250ms
          update_interval: 500ms
          min_brightness: 10%
          max_brightness: 50%
      - pulse:
          name: fast_pulse
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 25%
          max_brightness: 100%
    web_server:
      sorting_group_id: Diagnostic
      sorting_weight: 12

interval:
  - interval: 10s
    then:
      if:
        condition:
          wifi.connected:
        then:
          if:
            condition:
              api.connected:
            then:
              - light.turn_on:
                  id: status_led
                  brightness: 50%
                  red: 0
                  green: 100%
                  blue: 0
                  effect: None
            else:
              - light.turn_on:
                  id: status_led
                  brightness: 50%
                  red: 0
                  green: 100%
                  blue: 0
                  effect: slow_pulse              
        else:
          if:
            condition:
              - lambda: 'return id(id_captive_portal).is_active();'
            then:
              - light.turn_on:
                  id: status_led
                  brightness: 100%
                  red: 0
                  green: 0
                  blue: 100%
            else:
              - light.turn_on:
                  id: status_led
                  brightness: 100%
                  red: 100%
                  green: 0
                  blue: 0

## knop op de atom ingedrukt houden = veranderen brightness
script:
  - id: adjust_brightness_loop
    mode: restart
    then:
      - repeat:
          count: 1000
          then:
            - lambda: |-
                static float brightness = 0.0;
                brightness += 0.1;
                if (brightness > 1.0) brightness = 0.0;
                auto call = id(status_led).make_call();
                call.set_brightness(brightness);
                call.perform();
            - delay: 750ms