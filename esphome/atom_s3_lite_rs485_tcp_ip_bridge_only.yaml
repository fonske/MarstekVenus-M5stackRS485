substitutions:
  name: marstek_m1_bridge
  friendly_name: MT1_bridge

## Version 1.1
esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.7.0
  name_add_mac_suffix: false
  platformio_options:
    board_build.flash_mode: dio

  # Run on boot: publish whether the bridge is enabled
  on_boot:
    priority: 600
    then:
      - lambda: |-
          id(mb_bridge_enabled).publish_state(id(mb_bridge).is_enabled());

esp32:
  board: esp32-s3-devkitc-1  ## M5stack Atom S3 lite  
  flash_size: 8MB
  variant: esp32s3
  cpu_frequency: 240MHz
  framework:
    type: esp-idf
    ## Custom sdkconfig options
    sdkconfig_options:
      COMPILER_OPTIMIZATION_SIZE: y
      CONFIG_BT_ENABLED: n

## Modbus TCP/IP external component
external_components:
  - source:
      type: git
      url: https://github.com/rosenrot00/esphome_modbus_bridge
    components: [modbus_bridge]
    refresh: always

## Enable/Disable logging
logger:
  logs:
    modbus_controller.sensor: INFO
    modbus_controller.output: INFO
    modbus.number: INFO
    esp32.preferences: INFO
    light: INFO
    component: ERROR
  
## Enable Home Assistant API
api:
  reboot_timeout: 0s
#  encryption:
#    key: !secret marstek_m1_api_encryption_key

## Enable OTA updates
ota:
  - platform: esphome
#  - platform: web_server
#  password: !secret marstek_m1_ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 0s
#  fast_connect: true
#  power_save_mode: high

## uncomment if you need a fixed ip address
#  manual_ip:
#    static_ip: 192.168.0.180
#    gateway: 192.168.0.1
#    subnet: 255.255.255.0

## Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${friendly_name} Hotspot"
    password: "configesp"
    ap_timeout: 15s

captive_portal:
  id: id_captive_portal

web_server:
  port: 80
  version: 3
  include_internal: False
  local: True
#  sorting_groups:
#    - id: Diagnostic
#      name: "Diagnostic"
#      sorting_weight: -10

## Configure UART
uart:
  - id: mod_bus
    tx_pin:
      number: GPIO6
    rx_pin:
      number: GPIO5
    baud_rate: 115200
    data_bits: 8
    stop_bits: 1
    parity: NONE
    rx_buffer_size: 768         # min. 256 recommended; increase for very long RTU responses

## Configure MODBUS TCP/IP bridge
modbus_bridge:
  id: mb_bridge
  uart_id: mod_bus
  tcp_port: 502               # TCP port
  rtu_response_timeout: 3000     # ms, internally clamped to >=10 ms
  #tcp_poll_interval: 100       # ms between TCP polls
  #tcp_client_timeout: 120000   # ms inactivity until TCP client is disconnected
  #tcp_allowed_clients: 2      # clamped to minimum 1, use with care as it increases memory usage
  #rtu_response_timeout: 60000  # ms, clamped internally to minimum of 10 ms)

  # Event: triggered whenever number of TCP clients changes
  on_tcp_clients_changed:
    then:
      - lambda: |-
          id(tcp_clients) = count;
      - logger.log:
          format: "TCP clients connected: %d"
          args: ['count']
      - sensor.template.publish:
            id: mb_tcp_clients
            state: !lambda |-
              return (int) count;

  # Other available events (use similarly):
  # on_rtu_send:       # (function_code, address) â€“ triggered for every RTU command sent
  # on_rtu_receive:    # (function_code, address) â€“ triggered for every valid RTU response
  # on_rtu_timeout:    # (function_code, address) â€“ triggered for RTU timeouts
  # on_tcp_started:    # () â€“ triggered when TCP server successfully starts
  # on_tcp_stopped:    # () â€“ triggered when TCP server stops or IP is lost

modbus:
  - uart_id: mod_bus
    id: modbus1
    send_wait_time: 20ms

modbus_controller:
  - id: mt
    address: 0x1
    modbus_id: modbus1
    command_throttle: 20ms
    update_interval: 2s

# Global variable to store connected TCP client count
globals:
  - id: tcp_clients
    type: int
    restore_value: no
    initial_value: '0'

## Configure Debug Switch (Webserver debug window)
switch:
  - platform: template
    name: "Modbus TCP/IP Bridge Debug"
    id: modbus_debug_switch
    icon: mdi:file-document-check-outline
    restore_mode: RESTORE_DEFAULT_OFF  # debug disabled by default; persists across reboots
    turn_on_action:
      - lambda: |-
          id(mb_bridge).set_debug(true);
          id(modbus_debug_switch).publish_state(true);
    turn_off_action:
      - lambda: |-
          id(mb_bridge).set_debug(false);
          id(modbus_debug_switch).publish_state(false);
    entity_category: diagnostic

  # Switch: enable/disable the Modbus bridge itself
  - platform: template
    id: mb_bridge_enabled
    name: "Modbus Bridge Enabled"
    restore_mode: "ALWAYS_ON"
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(mb_bridge).set_enabled(true);
    turn_off_action:
      - lambda: |-
          id(mb_bridge).set_enabled(false);

debug:
  update_interval: 60s

## Textsensors diagnostics
text_sensor:
#  ## DEBUG
  - platform: debug
#    reset_reason:
#      name: "Reset Reason"
#      entity_category: diagnostic
  ## END DEBUG
    device:
      name: "Device Info"
      entity_category: diagnostic
  ## END DEBUG

  - platform: wifi_info
    ip_address:
      name: ESP IP
      icon: mdi:ip
#      web_server:
#        sorting_group_id: Diagnostic
#        sorting_weight: 1
#    ssid:
#      name: ESP SSID
#      icon: mdi:wifi
#      web_server:
#        sorting_group_id: Diagnostic
#        sorting_weight: 2

#  - platform: version
#    name: ESP Version
#    hide_timestamp: true
#    disabled_by_default: false
#    icon: mdi:new-box
#    entity_category: diagnostic
#    web_server:
#      sorting_group_id: Diagnostic
#      sorting_weight: 6

sensor:
  - platform: template
    name: "TCP Clients"
    id: mb_tcp_clients
    accuracy_decimals: 0
    update_interval: never

  #- platform: template
  #  name: "MB Frames In"
  #  accuracy_decimals: 0
  #  update_interval: 10s
  #  lambda: |-
  #    return (float) id(mb_bridge).get_frames_in();

  #- platform: template
  #  name: "MB Frames Out"
  #  accuracy_decimals: 0
  #  update_interval: 10s
  #  lambda: |-
  #    return (float) id(mb_bridge).get_frames_out();

  - platform: template
    name: "TCP Drops PID"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      return (int) id(mb_bridge).get_drops_pid();

  - platform: template
    name: "Drops LEN"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      return (int) id(mb_bridge).get_drops_len();

  - platform: template
    name: "RTU Timeouts"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      return (int) id(mb_bridge).get_timeouts();

  - platform: template
    name: "TCP Clients Total"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      return (int) id(mb_bridge).get_clients_connected_total();

  - platform: template
    name: "TCP No Slot Events"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      return (int) id(mb_bridge).get_noslot_events();

  - platform: template
    name: "TCP Preempt Events"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      return (int) id(mb_bridge).get_preempt_events();

#  - platform: internal_temperature
#    icon: mdi:thermometer
#    name: "Atom temperature"
#    update_interval: 30s
#    entity_category: diagnostic
 #   web_server:
 #     sorting_group_id: Diagnostic
 #     sorting_weight: 7

 # - platform: wifi_signal
 #   name: "ESP WiFi Signal Strength"
 #   icon: mdi:wifi
 #   id: wifi_strength
 #   update_interval: 30s
 #   entity_category: diagnostic
 #   web_server:
 #     sorting_group_id: Diagnostic
 #     sorting_weight: 4

 # - platform: copy # Reports the WiFi signal strength in %
 #   source_id: wifi_strength
 #   name: ESP Wifi signal
 #   id: wifi_signal_proc
 #   filters:
 #     - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
 #   unit_of_measurement: "%"
 #   entity_category: diagnostic
 #   device_class: ""
 #   icon: mdi:wifi
 #   web_server:
 #     sorting_group_id: Diagnostic
 #     sorting_weight: 5

## Simple status led for Atom s3 (lite)
## G35=RGB WS2812C-2020
##
## ðŸŸ¢ Green on => wifi connected- api connected/ Green blinking => wifi connected - api disconnected
## ðŸŸ£ Purple => wifi disconnected
## ðŸ”µ Blue => AP mode
light:
  - platform: esp32_rmt_led_strip
    id: status_led
    name: Status led
    icon: mdi:lightbulb
    internal: true # Hides from Home Assistant
    rgb_order: GRB
    pin: 35
    num_leds: 4
    chipset: ws2812
#    rmt_channel: 0 #only on platform: arduino
    restore_mode: ALWAYS_OFF
    entity_category: diagnostic
    effects:
      - pulse:
          name: slow_pulse
          transition_length: 250ms
          update_interval: 500ms
          min_brightness: 10%
          max_brightness: 50%
      - pulse:
          name: fast_pulse
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 25%
          max_brightness: 100%
#    web_server:
#      sorting_group_id: Diagnostic
#      sorting_weight: 12

interval:
  - interval: 10s
    then:
      if:
        condition:
          wifi.connected:
        then:
          if:
            condition:
              api.connected:
            then:
              - light.turn_on:
                  id: status_led
                  brightness: 50%
                  red: 0
                  green: 100%
                  blue: 0
                  effect: None
            else:
              - light.turn_on:
                  id: status_led
                  brightness: 50%
                  red: 0
                  green: 100%
                  blue: 0
                  effect: slow_pulse              
        else:
          if:
            condition:
              - lambda: 'return id(id_captive_portal).is_active();'
            then:
              - light.turn_on:
                  id: status_led
                  brightness: 100%
                  red: 0
                  green: 0
                  blue: 100%
            else:
              - light.turn_on:
                  id: status_led
                  brightness: 100%
                  red: 100%
                  green: 0
                  blue: 0

## knop op de atom ingedrukt houden = veranderen brightness
script:
  - id: adjust_brightness_loop
    mode: restart
    then:
      - repeat:
          count: 1000
          then:
            - lambda: |-
                static float brightness = 0.0;
                brightness += 0.1;
                if (brightness > 1.0) brightness = 0.0;
                auto call = id(status_led).make_call();
                call.set_brightness(brightness);
                call.perform();
            - delay: 750ms
